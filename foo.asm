# MIPS CODE GENERATED by Compiler

.data

_L0: .asciiz	 "success\n"
_L1: .asciiz	 "\n"
_L2: .asciiz	 "\n"
_L3: .asciiz	 "success\n"
_L4: .asciiz	 "fail\n"
_L5: .asciiz	 "success\n"
_L6: .asciiz	 "first\n"
_L7: .asciiz	 "\n"
_L8: .asciiz	 "success\n"
_L9: .asciiz	 "success\n"
_L10: .asciiz	 "success\n"
_L11: .asciiz	 "success\n"
.align 2
h: .space 4 # global variable
.text


.globl main


foo2:				# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 12		# Activation Record carve out copy size of function
	sw $ra , ($a1)		# Store Return address 
	sw $sp 4($a1)		# Store the old Stack pointer
	move $sp, $a1		# Make SP the current activation record


	sw $t0 8($sp)		# Paramater store start of function


	li $a0, 5		# expression is a constant
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller
	li $a0, 0		# RETURN has no specified value set to 0
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller

			# END OF FUNCTION



vfoo:				# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 8		# Activation Record carve out copy size of function
	sw $ra , ($a1)		# Store Return address 
	sw $sp 4($a1)		# Store the old Stack pointer
	move $sp, $a1		# Make SP the current activation record




	la $a0, _L0		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	li $a0, 0		# RETURN has no specified value set to 0
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller

			# END OF FUNCTION



foo:				# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 52		# Activation Record carve out copy size of function
	sw $ra , ($a1)		# Store Return address 
	sw $sp 4($a1)		# Store the old Stack pointer
	move $sp, $a1		# Make SP the current activation record


	sw $t1 8($sp)		# Paramater store start of function


	li $a0, 4		# expression is a constant
	sw $a0, 20($sp)		# expression store LHS temporarily
	li $a0, 3		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 20($sp)		# expression restore LHS from memory
	add $a0, $a0, $a1		# EXPR +
	sw $a0, 28($sp)		# expression store LHS temporarily
	li $a0, 2		# expression is a constant
	sw $a0, 24($sp)		# expression store LHS temporarily
	li $a0, 5		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 24($sp)		# expression restore LHS from memory
	mult $a0 $a1		# EXPR *
	mflo $a0		# EXPR *
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 28($sp)		# expression restore LHS from memory
	sub $a0, $a0, $a1		# EXPR -
	sw $a0 32($sp)		# Assign store RHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# VAR local stack pointer plus offset
	lw $a1 32($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
			# Setting Up Function Call
			# evaluate  Function Parameters
			# place   Parameters into T registers

	jal vfoo			# Call the function


			# Setting Up Function Call
			# evaluate  Function Parameters
	la $a0, h		# EMIT Var global variable
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 36($sp)		# Store call Arg temporarily

			# place   Parameters into T registers
	lw $a0, 36($sp)		# pull out stored  Arg 
	move $t0, $a0		# move arg in temp 

	jal foo2			# Call the function


	neg $a0, $a0		# Switch the sign to implement unary minus
	sw $a0 44($sp)		# Assign store RHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# VAR local stack pointer plus offset
	lw $a1 44($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 48($sp)		# expression store LHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 48($sp)		# expression restore LHS from memory
	add $a0, $a0, $a1		# EXPR +
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller
	li $a0, 0		# RETURN has no specified value set to 0
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller

			# END OF FUNCTION



foo3:				# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 8		# Activation Record carve out copy size of function
	sw $ra , ($a1)		# Store Return address 
	sw $sp 4($a1)		# Store the old Stack pointer
	move $sp, $a1		# Make SP the current activation record




	li $a0, 0		# expression is a constant
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller
	li $a0, 0		# RETURN has no specified value set to 0
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra			# return to the caller

			# END OF FUNCTION



main:				# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 864		# Activation Record carve out copy size of function
	sw $ra , ($a1)		# Store Return address 
	sw $sp 4($a1)		# Store the old Stack pointer
	move $sp, $a1		# Make SP the current activation record




			# Setting Up Function Call
			# evaluate  Function Parameters
	li $a0, 2		# expression is a constant
	sw $a0, 812($sp)		# Store call Arg temporarily

			# place   Parameters into T registers
	lw $a0, 812($sp)		# pull out stored  Arg 
	move $t1, $a0		# move arg in temp 

	jal foo			# Call the function


	li $v0, 1		# About to print a number
	syscall			# call write number


	la $a0, _L1		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


			# Setting Up Function Call
			# evaluate  Function Parameters
			# place   Parameters into T registers

	jal foo3			# Call the function


	li $v0, 1		# About to print a number
	syscall			# call write number


	la $a0, _L2		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


			# Setting Up Function Call
			# evaluate  Function Parameters
			# place   Parameters into T registers

	jal foo3			# Call the function


	sw $a0, 816($sp)		# expression store LHS temporarily
	li $a0, 5		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 816($sp)		# expression restore LHS from memory
	slt $a0, $a0, $a1		# EXPR >
	beq $a0 $0 _L12		# IF branch to else part

			#  the positive portion of if
	la $a0, _L3		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L13		# IF S1 end
_L12:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L13:			# END of IF
			# Setting Up Function Call
			# evaluate  Function Parameters
			# place   Parameters into T registers

	jal foo3			# Call the function


	sw $a0, 824($sp)		# expression store LHS temporarily
	li $a0, 1		# expression is a constant
	neg $a0, $a0		# Switch the sign to implement unary minus
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 824($sp)		# expression restore LHS from memory
	slt $a0, $a0, $a1		# EXPR >
	beq $a0 $0 _L14		# IF branch to else part

			#  the positive portion of if
	la $a0, _L4		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L15		# IF S1 end
_L14:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
	la $a0, _L5		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


_L15:			# END of IF
	li $a0, 10		# expression is a constant
	sw $a0 828($sp)		# Assign store RHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a1 828($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
_L16:			# WHILE TOP target
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 832($sp)		# expression store LHS temporarily
	li $a0, 0		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 832($sp)		# expression restore LHS from memory
	slt $a0, $a1, $a0		# EXPR <
	beq $a0 $0 _L17		# WHILE branch out
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 836($sp)		# expression store LHS temporarily
	li $a0, 10		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 836($sp)		# expression restore LHS from memory
	slt $t2 ,$a0, $a1		# EXPR ==
	slt $t3 ,$a1, $a0		# EXPR ==
	nor $a0 ,$t2, $t3		# EXPR ==
	andi $a0 , 1		# EXPR ==
	beq $a0 $0 _L18		# IF branch to else part

			#  the positive portion of if
	la $a0, _L6		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L19		# IF S1 end
_L18:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L19:			# END of IF
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	li $v0, 1		# About to print a number
	syscall			# call write number


	la $a0, _L7		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 840($sp)		# expression store LHS temporarily
	li $a0, 1		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 840($sp)		# expression restore LHS from memory
	sub $a0, $a0, $a1		# EXPR -
	sw $a0 844($sp)		# Assign store RHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a1 844($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
	j _L16		# WHILE jump back
_L17:			# END of while
	li $a0, 4		# expression is a constant
	sw $a0 836($sp)		# Assign store RHS temporarily
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a1 836($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 840($sp)		# expression store LHS temporarily
	li $a0, 4		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 840($sp)		# expression restore LHS from memory
	slt $t2 ,$a0, $a1		# EXPR ==
	slt $t3 ,$a1, $a0		# EXPR ==
	nor $a0 ,$t2, $t3		# EXPR ==
	andi $a0 , 1		# EXPR ==
	beq $a0 $0 _L20		# IF branch to else part

			#  the positive portion of if
	la $a0, _L8		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L21		# IF S1 end
_L20:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L21:			# END of IF
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 844($sp)		# expression store LHS temporarily
	li $a0, 5		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 844($sp)		# expression restore LHS from memory
	slt $t2 ,$a0, $a1		# EXPR !=
	slt $t3 ,$a1, $a0		# EXPR !=
	or $a0 ,$t2, $t3		# EXPR !=
	beq $a0 $0 _L22		# IF branch to else part

			#  the positive portion of if
	la $a0, _L9		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L23		# IF S1 end
_L22:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L23:			# END of IF
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 848($sp)		# expression store LHS temporarily
	li $a0, 4		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 848($sp)		# expression restore LHS from memory
	add $a1, $a1, 1		# EXPR >= add one to do compare
	slt $a0, $a0, $a1		# EXPR >=
	beq $a0 $0 _L24		# IF branch to else part

			#  the positive portion of if
	la $a0, _L10		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L25		# IF S1 end
_L24:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L25:			# END of IF
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# Expression is a VAR
	sw $a0, 852($sp)		# expression store LHS temporarily
	li $a0, 4		# expression is a constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 852($sp)		# expression restore LHS from memory
	add $a0, $a0, 1		# EXPR <= add one to do compare
	slt $a0, $a1, $a0		# EXPR <=
	beq $a0 $0 _L26		# IF branch to else part

			#  the positive portion of if
	la $a0, _L11		# The string address
	li $v0, 4		# About to print a string
	syscall			# call write string


	j _L27		# IF S1 end
_L26:			# ELSE target
			#  the negative  portion of IF if there is an else
			#  otherwise just these lines
_L27:			# END of IF
	li $a0, 40		# expression is a constant
	sw $a0 856($sp)		# Assign store RHS temporarily
	li $a0, 0		# expression is a constant
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# multiply the index by wordsize via SLL
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 412		# VAR local stack pointer plus offset
	add $a0 $a0 $a1		# VAR array add internal offset
	lw $a1 856($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
	li $a0, 5		# expression is a constant
	sw $a0 860($sp)		# Assign store RHS temporarily
	li $a0, 0		# expression is a constant
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# multiply the index by wordsize via SLL
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 412		# VAR local stack pointer plus offset
	add $a0 $a0 $a1		# VAR array add internal offset
	lw $a0, ($a0)		# Expression is a VAR
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# multiply the index by wordsize via SLL
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# VAR local stack pointer plus offset
	add $a0 $a0 $a1		# VAR array add internal offset
	lw $a1 860($sp)		# Assign get RHS temporarily
	sw $a1 ($a0)		# Assign place RHS into memory
	li $a0, 40		# expression is a constant
	move $a1, $a0		# VAR copy index array in a1
	sll $a1 $a1 2		# multiply the index by wordsize via SLL
	move $a0 $sp		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# VAR local stack pointer plus offset
	add $a0 $a0 $a1		# VAR array add internal offset
	lw $a0, ($a0)		# Expression is a VAR
	li $v0, 1		# About to print a number
	syscall			# call write number


	li $a0, 0		# RETURN has no specified value set to 0
	lw $ra ($sp)		# restore old environment RA
	lw $sp 4($sp)		# Return from function store SP

	li $v0, 10		# Exit from Main we are done
	syscall			# EXIT everything

			# END OF FUNCTION


